// Programa para análisis léxico y sintáctico en JavaCC
options {
    STATIC = true;
}

PARSER_BEGIN(Parser)
package com.lexico.analizador;

public class Parser {
    public static void main(String[] args) throws ParseException {
        System.out.println("Bienvenidos al Compilador de JIDE-73");
        System.out.println("---------------------------------------------------");

        Parser parser = new Parser(System.in);
        parser.program(); // Invoca la regla principal de la gramática

        System.out.println("No fallé jeje");
    }
}
PARSER_END(Parser)

// Ignorar espacios en blanco, saltos de línea y tabulaciones
SKIP : {
    " " | "\r" | "\t" | "\n"
}


TOKEN : {
    // ============================================================
    // Operadores de asignación
    // ============================================================
    <LEFT_SHIFT_ASSIGN: "<<=">
  | <RIGHT_SHIFT_ASSIGN: ">>=">
  | <POW_ASSIGN: "**=">
  | <PLUS_ASSIGN: "+=">
  | <MINUS_ASSIGN: "-=">
  | <MULT_ASSIGN: "*=">
  | <DIV_ASSIGN: "/=">
  | <MOD_ASSIGN: "%=">
  | <AND_ASSIGN: "&=">
  | <OR_ASSIGN: "|=">
  | <XOR_ASSIGN: "^=">
  | <ASSIGN: "=">

    // ============================================================
    // Operadores aritméticos
    // ============================================================
  | <POW: "**">
  | <INT_DIV: "//">
  | <PLUS: "+">
  | <MINUS: "-">
  | <DIV: "/">
  | <MOD: "%">

    // ============================================================
    // Incremento / Decremento
    // ============================================================
  | <INCREMENT: "++">
  | <DECREMENT: "--">

    // ============================================================
    // Comparación
    // ============================================================
  | <STRICT_EQ: "===">
  | <STRICT_NEQ: "!==">
  | <LE: "<=">
  | <GE: ">=">
  | <EQ: "==">
  | <NEQ: "!=">
  | <LEFT_SHIFT: "<<">
  | <UNSIGNED_SHIFT: ">>>">
  | <RIGHT_SHIFT: ">>">
  | <LT: "<">
  | <GT: ">">

    // ============================================================
    // Lógicos
    // ============================================================
  | <AND: "&&">
  | <OR: "||">
  | <NOT: "!">

    // ============================================================
    // Bit a bit
    // ============================================================
  | <BIT_XOR: "^">
  | <BIT_NOT: "~">

    // ============================================================
    // Varios
    // ============================================================
  | <NULL_COALESCE: "\\?\\?">
  | <NULL_SAFE: "\\?\\.">
  | <RANGE_INCL: "...">
  | <RANGE: "..">
  | <TERNARY: "\\?">
  | <COLON: ":">
  | <PIPE: "|">
  | <DOT: ".">
  | <COMMA: ",">
  | <SEMICOLON: ";">
  | <DOUBLE_SEMICOLON: ";;">
  | <UNDERSCORE: "_">

    // ============================================================
    // Delimitadores
    // ============================================================
  | <LPAREN: "(">
  | <RPAREN: ")">
  | <LBRACE: "{">
  | <RBRACE: "}">
  | <LBRACKET: "[">
  | <RBRACKET: "]">

    // ============================================================
    // Tipos de datos
    // ============================================================
  | <INT8: "int8">
  | <INT16: "int16">
  | <INT32: "int32">
  | <INT64: "int64">
  | <UINT8: "uint8">
  | <UINT16: "uint16">
  | <UINT32: "uint32">
  | <UINT64: "uint64">
  | <FLOAT32: "float32">
  | <FLOAT64: "float64">
  | <INTEGER: "integer">
  | <NUMBER: "number">
  | <DECIMAL: "decimal">
  | <DOUBLE: "double">
  | <CHAR: "char">
  | <RUNE: "rune">
  | <BYTE: "byte">
  | <STRING: "string">
  | <BOOLEAN: "bool">
  | <ANY: "any">
  | <VOID: "void">
  | <NULL: "null">
  | <UNDEFINED: "undefined">
  | <NEVER: "never">
  | <UNKNOWN: "unknown">
  | <NONE: "none">
  | <TRUE: "true">
  | <FALSE: "false">

    // ============================================================
    // Estructuras de datos
    // ============================================================
  | <ARRAY: "array">
  | <LIST: "list">
  | <TUPLE: "tuple">
  | <MAP: "map">
  | <DICT: "dict">
  | <OBJECT: "object">
  | <RECORD: "record">
  | <STRUCT: "struct">
  | <ENUM: "enum">
  | <INTERFACE: "interface">
  | <CLASS: "class">

    // ============================================================
    // Modificadores de acceso / variables
    // ============================================================
  | <PUBLIC: "public">
  | <PRIVATE: "private">
  | <PROTECTED: "protected">
  | <INTERNAL: "internal">
  | <READONLY: "readonly">
  | <WRITEONLY: "writeonly">
  | <FRIEND: "friend">
  | <PACKAGE_VIS: "package">
  | <CONST: "const">
  | <LET: "let">
  | <VAR: "var">
  | <STATIC: "static">
  | <FINAL: "final">
  | <ABSTRACT: "abstract">
  | <VIRTUAL: "virtual">
  | <SEALED: "sealed">
  | <IMMUTABLE: "immutable">
  | <MUTABLE: "mutable">
  | <VOLATILE: "volatile">
  | <EXTERN: "extern">
  | <REGISTER: "register">
  | <OVERRIDE: "override">
  | <EXPLICIT: "explicit">
  | <IMPLICIT: "implicit">

    // ============================================================
    // Control de flujo
    // ============================================================
  | <IF: "if">
  | <ELSE: "else">
  | <ELIF: "elif">
  | <SWITCH: "switch">
  | <CASE: "case">
  | <DEFAULT_CASE: "default">
  | <WHILE: "while">
  | <DO_WHILE: "do">
  | <FOR: "for">
  | <FOREACH: "foreach">
  | <LOOP: "loop">
  | <UNTIL: "until">
  | <MATCH: "match">
  | <WHEN: "when">
  | <OF: "of">
  | <IN: "in">

    // ============================================================
    // Saltos
    // ============================================================
  | <BREAK: "break">
  | <CONTINUE: "continue">
  | <RETURN: "return">
  | <YIELD: "yield">
  | <THROW: "throw">
  | <RETHROW: "rethrow">
  | <GOTO: "goto">
  | <EXIT: "exit">

    // ============================================================
    // Excepciones
    // ============================================================
  | <TRY: "try">
  | <CATCH: "catch">
  | <FINALLY: "finally">
  | <THROWS: "throws">
  | <EXCEPTION: "exception">
  | <ASSERT: "assert">
  | <ENSURE: "ensure">

    // ============================================================
    // Asíncrono / concurrencia
    // ============================================================
  | <ASYNC: "async">
  | <AWAIT: "await">
  | <SPAWN: "spawn">
  | <THREAD: "thread">
  | <SYNC: "sync">
  | <LOCK: "lock">
  | <MUTEX: "mutex">

    // ============================================================
    // Funciones
    // ============================================================
  | <FUNCTION: "function">
  | <METHOD: "method">
  | <PROCEDURE: "procedure">
  | <CONSTRUCTOR: "constructor">
  | <DESTRUCTOR: "destructor">
  | <OPERATOR: "operator">
  | <GETTER: "get">
  | <SETTER: "set">
  | <PROPERTY: "property">

    // ============================================================
    // Memoria / punteros
    // ============================================================
  | <NEW: "new">
  | <DELETE: "delete">
  | <FREE: "free">
  | <MALLOC: "malloc">
  | <CALLOC: "calloc">
  | <REALLOC: "realloc">
  | <ALLOCATE: "allocate">
  | <GC: "gc">
  | <STAR: "*">
  | <AMP: "&">
  | <MUT_REF: "&mut">
  | <UNIQUE_PTR: "unique_ptr">
  | <SHARED_PTR: "shared_ptr">
  | <SMART_PTR: "Box">

    // ============================================================
    // Módulos / imports
    // ============================================================
  | <IMPORT: "import">
  | <EXPORT: "export">
  | <MODULE: "module">
  | <NAMESPACE: "namespace">
  | <USING: "using">
  | <FROM: "from">
  | <INCLUDE: "include">
  | <REQUIRE_JS: "require">

    // ============================================================
    // Templates / tipos
    // ============================================================
  | <TEMPLATE: "template">
  | <WHERE: "where">
  | <TYPE: "type">
  | <TYPEOF: "typeof">
  | <INSTANCEOF: "instanceof">
  | <AS: "as">
  | <IS: "is">
  | <SIZEOF: "sizeof">

    // ============================================================
    // Referencias / contexto
    // ============================================================
  | <THIS: "this">
  | <SELF: "self">
  | <SUPER: "super">
  | <BASE: "base">
  | <PARENT: "parent">
  | <ROOT: "root">
  | <LOCAL: "local">
  | <GLOBAL: "global">

    // ============================================================
    // Decoradores
    // ============================================================
  | <AT: "@">
  | <METADATA: "metadata">

    // ============================================================
    // SQL (sin espacios)
    // ============================================================
  | <SELECT: "select">
  | <FROM_SQL: "from_sql">
  | <WHERE_SQL: "where_sql">
  | <JOIN_SQL: "join_sql">
  | <ON_SQL: "on_sql">
  | <GROUP_BY_SQL: "group_by">
  | <ORDER_BY_SQL: "order_by">
  | <HAVING: "having">
  | <INSERT: "insert">
  | <INTO: "into">
  | <VALUES: "values">
  | <UPDATE: "update">
  | <SET_SQL: "set_sql">
  | <DELETE_SQL: "delete_sql">
  | <DISTINCT: "distinct">
  | <UNION: "union">
  | <INTERSECT: "intersect">
  | <EXCEPT: "except">
  | <LIMIT: "limit">
  | <OFFSET: "offset">
  | <INNER_JOIN: "inner_join">
  | <LEFT_JOIN: "left_join">
  | <RIGHT_JOIN: "right_join">
  | <FULL_JOIN: "full_join">
  | <CROSS_JOIN: "cross_join">

    // ============================================================
    // HTTP
    // ============================================================
  | <HTTP_GET: "get_">
  | <POST: "post">
  | <PUT: "put">
  | <PATCH: "patch">
  | <DELETE_HTTP: "http_delete">
  | <HEAD: "head">
  | <OPTIONS: "options">
  | <HTTP: "http">
  | <HTTPS: "https">
  | <REST: "rest">
  | <GRAPHQL: "graphql">
  | <WEBSOCKET: "websocket">

    // ============================================================
    // Patrones de diseño
    // ============================================================
  | <CONTROLLER: "controller">
  | <SERVICE: "service">
  | <REPOSITORY: "repository">
  | <MIDDLEWARE: "middleware">
  | <ROUTE: "route">
  | <ENDPOINT: "endpoint">

    // ============================================================
    // Literales numéricos
    // ============================================================
  | <INT: (["0"-"9"])+>
  | <FLOAT: (["0"-"9"])+ "." (["0"-"9"])+>
  | <FLOAT2: (["0"-"9"])+ ".">
  | <FLOAT3: "." (["0"-"9"])+>
  | <SCIENCE: (["0"-"9"])+ ("." (["0"-"9"])+)? (["e","E"] (["+","-"])? (["0"-"9"])+)>
  | <HEX: "0" ["x","X"] (["0"-"9","a"-"f","A"-"F"])+>
  | <OCTAL: "0" ["o","O"] (["0"-"7"])+>
  | <BINARY: "0" ["b","B"] (["0","1"])+>
  | <NAN: "NaN">
  | <INFINITY: "Infinity">

    // ============================================================
    // Literales de cadena
    // ============================================================
  | <STRING_LIT: "\"" (~["\"", "\\"] | ("\\" "."))* "\"">
  | <CHAR_LIT: "'" (~["'", "\\"] | ("\\" "."))* "'">
  | <ESCAPE_CHAR: "\\" ["n","r","t","0","'","\"", "\\"]>
  | <TEMPLATE_STRING: "`" (~["`"] | "\\`")* "`">
  | <RAW_STRING: "@\"" (~["\""] | "\"\"")* "\"">
  | <MULTILINE_STRING: "\"\"\"" (~["\""] | "\"" (~["\""] | "\"" (~["\""])*))* "\"\"\"">

    // ============================================================
    // Preprocesador
    // ============================================================
  | <PREPROC: "#" (~["\n"])*>
  | <INCLUDE_DIR: "#include">
  | <DEFINE: "#define">
  | <IFDEF: "#ifdef">
  | <IFNDEF: "#ifndef">
  | <ENDIF: "#endif">
  | <PRAGMA: "#pragma">
  | <SHEBANG: "#!" (~["\n"])*>

    // ============================================================
    // Comentarios
    // ============================================================
  | <LINE_COMMENT: "//" (~["\n"])*>
  | <BLOCK_COMMENT: "/*" (~["*"] | "*" (~["/"]))* "*/">
  | <DOC_COMMENT: "/**" (~["*"] | "*" (~["/"]))* "*/">

    // ============================================================
    // Identificadores
    // ============================================================
  | <IDENTIFIER: ["a"-"z","A"-"Z","_"] (["a"-"z","A"-"Z","0"-"9","_"])*>
  | <GLOBAL_ID: ["A"-"Z"] (["A"-"Z","0"-"9","_"])*>
  | <PRIVATE_ID: "_" (["a"-"z","A"-"Z","0"-"9","_"])+>
  | <INTERNAL_ID: "__" (["a"-"z","A"-"Z","0"-"9","_"])+>
  | <SPECIAL_VAR: "$" (["a"-"z","A"-"Z","0"-"9","_"])+>
  | <CONTEXT_VAR: "@" (["a"-"z","A"-"Z","0"-"9","_"])+>
  | <TYPE_PARAM: ["A"-"Z"] (["a"-"z","A"-"Z"])*>
}

// ============================================================
// GRAMÁTICA SINTÁCTICA
// ============================================================

// Regla principal que inicia el análisis
void program() :
{}
{
    ( statement() )*
    <EOF>
}

// ============================================================
// OPERADORES FALTANTES
// ============================================================

// Para los operadores < y > que faltan en tokens
void ARROW() : {} { <MINUS> <GT> }
void ASC() : {} { "ASC" }
void DESC() : {} { "DESC" }
void EXTENDS() : {} { "extends" }
void IMPLEMENTS() : {} { "implements" }
void ANNOTATION() : {} { <AT> <IDENTIFIER> }

// Declaración principal de sentencias
void statement() :
{}
{
    LOOKAHEAD( declarationStatement() ) declarationStatement()
    | LOOKAHEAD( controlFlowStatement() ) controlFlowStatement()
    | LOOKAHEAD( jumpStatement() ) jumpStatement()
    | LOOKAHEAD( compoundStatement() ) compoundStatement()
    | LOOKAHEAD( functionDeclaration() ) functionDeclaration()
    | LOOKAHEAD( classDeclaration() ) classDeclaration()
    | expressionStatement()
    | emptyStatement()
    | importStatement()
    | exportStatement()
    | interfaceDeclaration()
    | structDeclaration()
    | enumDeclaration()
    | namespaceDeclaration()
    | templateDeclaration()
    | annotationStatement()
    | preprocessorStatement()
    | sqlStatement()
    | httpStatement()
    | synchronizationStatement()
    | memoryManagementStatement()
    | exceptionHandlingStatement()
    | assertionStatement()
}

// ============================================================
// DECLARACIONES
// ============================================================

void declarationStatement() :
{}
{
    (
        variableDeclaration()
        | constantDeclaration()
        | typeDeclaration()
    )
    <SEMICOLON>
}

void variableDeclaration() :
{}
{
    ( <VAR> | <LET> | <MUTABLE> | <IMMUTABLE> ) 
    <IDENTIFIER> 
    ( <COLON> baseType() ( typeSuffix() )* )?
    ( <ASSIGN> expression() )?
}

void constantDeclaration() :
{}
{
    <CONST> <IDENTIFIER> ( <COLON> type() )? <ASSIGN> expression()
}

void typeDeclaration() :
{}
{
    <TYPE> <IDENTIFIER> <ASSIGN> type()
}

// ============================================================
// EXPRESIONES (JERARQUÍA COMPLETA)
// ============================================================

void expressionStatement() :
{}
{
    expression() <SEMICOLON>
}

void expression() :
{}
{
    assignmentExpression()
}

void assignmentExpression() :
{}
{
    conditionalExpression()
    (
        ( <ASSIGN> | <PLUS_ASSIGN> | <MINUS_ASSIGN> | <MULT_ASSIGN> 
        | <DIV_ASSIGN> | <MOD_ASSIGN> | <AND_ASSIGN> | <OR_ASSIGN> 
        | <XOR_ASSIGN> | <LEFT_SHIFT_ASSIGN> | <RIGHT_SHIFT_ASSIGN>
        | <POW_ASSIGN> )
        assignmentExpression()
    )?
}

void conditionalExpression() :
{}
{
    logicalOrExpression()
    ( <TERNARY> expression() <COLON> conditionalExpression() )?
}

void logicalOrExpression() :
{}
{
    logicalAndExpression() ( <OR> logicalAndExpression() )*
}

void logicalAndExpression() :
{}
{
    bitwiseOrExpression() ( <AND> bitwiseOrExpression() )*
}

void bitwiseOrExpression() :
{}
{
    bitwiseXorExpression() ( <PIPE> bitwiseXorExpression() )*
}

void bitwiseXorExpression() :
{}
{
    bitwiseAndExpression() ( <BIT_XOR> bitwiseAndExpression() )*
}

void bitwiseAndExpression() :
{}
{
    equalityExpression() ( <AMP> equalityExpression() )*
}

void equalityExpression() :
{}
{
    relationalExpression() 
    ( 
        ( <EQ> | <NEQ> | <STRICT_EQ> | <STRICT_NEQ> | <IS> | <AS> ) 
        relationalExpression() 
    )*
}

void relationalExpression() :
{}
{
    shiftExpression()
    (
        ( <LT> | <GT> | <LE> | <GE> | <INSTANCEOF> | <IN> | <OF> )
        shiftExpression()
    )*
}

void shiftExpression() :
{}
{
    additiveExpression()
    ( ( <LEFT_SHIFT> | <RIGHT_SHIFT> | <UNSIGNED_SHIFT> ) additiveExpression() )*
}

void additiveExpression() :
{}
{
    multiplicativeExpression()
    ( ( <PLUS> | <MINUS> ) multiplicativeExpression() )*
}

void multiplicativeExpression() :
{}
{
    powerExpression()
    ( ( <STAR> | <DIV> | <MOD> | <INT_DIV> ) powerExpression() )*
}

void powerExpression() :
{}
{
    unaryExpression() ( <POW> unaryExpression() )*
}

void unaryExpression() :
{}
{
    ( 
        <PLUS> | <MINUS> | <NOT> | <BIT_NOT> | <INCREMENT> 
        | <DECREMENT> | <TYPEOF> | <SIZEOF>
        | <NEW> | <DELETE> | <THROW> | <AWAIT>
        | <STAR> | <AMP> | <MUT_REF>
    )
    unaryExpression()
    |
    postfixExpression()
}

void postfixExpression() :
{}
{
    primaryExpression()
    (
        <INCREMENT> 
        | <DECREMENT>
        | LOOKAHEAD(3) methodCall()
        | LOOKAHEAD(2) fieldAccess()
        | arrayAccess()
        | functionCall()
    )*
}

void primaryExpression() :
{}
{
    literal()
    | <IDENTIFIER>
    | <THIS> | <SELF> | <SUPER> | <BASE>
    | <NULL> | <TRUE> | <FALSE> | <UNDEFINED>
    | <GLOBAL_ID> | <PRIVATE_ID> | <INTERNAL_ID>
    | <SPECIAL_VAR> | <CONTEXT_VAR>
    | LOOKAHEAD(2) arrayLiteral()
    | LOOKAHEAD(2) objectLiteral()
    | LOOKAHEAD(2) tupleLiteral()
    | LOOKAHEAD(2) setLiteral()
    | LOOKAHEAD(2) mapLiteral()
    | <LPAREN> expression() <RPAREN>
}

// ============================================================
// LITERALES
// ============================================================

void literal() :
{}
{
    <INT> | <FLOAT> | <FLOAT2> | <FLOAT3> | <SCIENCE> 
    | <HEX> | <OCTAL> | <BINARY>
    | <STRING_LIT> | <CHAR_LIT> | <TEMPLATE_STRING> 
    | <RAW_STRING> | <MULTILINE_STRING>
    | <NAN> | <INFINITY>
}

void arrayLiteral() :
{}
{
    <LBRACKET> ( expression() ( <COMMA> expression() )* )? <RBRACKET>
}

void objectLiteral() :
{}
{
    <LBRACE> ( propertyAssignment() ( <COMMA> propertyAssignment() )* )? <RBRACE>
}

void propertyAssignment() :
{}
{
    ( <IDENTIFIER> | <STRING_LIT> ) ( <COLON> expression() )?
}

void tupleLiteral() :
{}
{
    <LPAREN> expression() ( <COMMA> expression() )+ <RPAREN>
}

void setLiteral() :
{}
{
    <LBRACE> expression() ( <COMMA> expression() )* <RBRACE>
}

void mapLiteral() :
{}
{
    <LBRACE> ( mapEntry() ( <COMMA> mapEntry() )* )? <RBRACE>
}

void mapEntry() :
{}
{
    expression() <COLON> expression()
}

// ============================================================
// CONTROL DE FLUJO
// ============================================================

void controlFlowStatement() :
{}
{
    ifStatement()
    | switchStatement()
    | whileStatement()
    | doWhileStatement()
    | forStatement()
    | foreachStatement()
    | matchStatement()
    | whenStatement()
    | loopStatement()
    | untilStatement()
}

void ifStatement() :
{}
{
    <IF> <LPAREN> expression() <RPAREN> statement()
    ( <ELIF> <LPAREN> expression() <RPAREN> statement() )*
    ( <ELSE> statement() )?
}

void switchStatement() :
{}
{
    <SWITCH> <LPAREN> expression() <RPAREN> 
    <LBRACE>
        ( <CASE> expression() <COLON> ( statement() )* )*
        ( <DEFAULT_CASE> <COLON> ( statement() )* )?
    <RBRACE>
}


void whileStatement() :
{}
{
    <WHILE> <LPAREN> expression() <RPAREN> statement()
}

void doWhileStatement() :
{}
{
    <DO_WHILE> statement() <WHILE> <LPAREN> expression() <RPAREN> <SEMICOLON>
}

void forStatement() :
{}
{
    <FOR> <LPAREN> 
        ( variableDeclaration() | ( expression() )? ) <SEMICOLON>
        ( expression() )? <SEMICOLON>
        ( expression() )?
    <RPAREN> statement()
}


void foreachStatement() :
{}
{
    <FOREACH> <LPAREN> <IDENTIFIER> <IN> expression() <RPAREN> statement()
}

void matchStatement() :
{}
{
    <MATCH> <LPAREN> expression() <RPAREN> 
    <LBRACE>
    ( pattern() ARROW() statement() )*
    <RBRACE>
}

void pattern() :
{}
{
    literal() 
    | <IDENTIFIER> 
    | <UNDERSCORE>
    | LOOKAHEAD(2) constructorPattern()
}

void constructorPattern() :
{}
{
    <IDENTIFIER> <LPAREN> ( pattern() ( <COMMA> pattern() )* )? <RPAREN>
}

void whenStatement() :
{}
{
    <WHEN> <LPAREN> expression() <RPAREN> 
    <LBRACE>
    ( conditionStatement() )*
    <RBRACE>
}

void conditionStatement() :
{}
{
    expression() ARROW() statement()
}

void loopStatement() :
{}
{
    <LOOP> statement()
}

void untilStatement() :
{}
{
    <UNTIL> <LPAREN> expression() <RPAREN> statement()
}

// ============================================================
// SALTOS
// ============================================================

void jumpStatement() :
{}
{
    (
        <BREAK> | <CONTINUE> | <RETURN> ( expression() )?
        | <YIELD> ( expression() )? | <THROW> expression()
        | <GOTO> <IDENTIFIER> | <EXIT> ( expression() )?
        | <RETHROW>
    )
    <SEMICOLON>
}

// ============================================================
// ESTRUCTURAS COMPUESTAS
// ============================================================

void compoundStatement() :
{}
{
    blockStatement()
    | tryCatchStatement()
}

void blockStatement() :
{}
{
    <LBRACE> ( statement() )* <RBRACE>
}

void emptyStatement() :
{}
{
    <SEMICOLON>
}

// ============================================================
// FUNCIONES Y MÉTODOS
// ============================================================

void functionDeclaration() :
{}
{
    ( <ASYNC> )? 
    ( <FUNCTION> | <METHOD> | <PROCEDURE> ) 
    ( <IDENTIFIER> | <OPERATOR> operatorOverload() )
    <LPAREN> ( parameterList() )? <RPAREN>
    ( <COLON> type() )?
    ( <THROWS> ( exceptionList() ) )?
    ( functionBody() | <SEMICOLON> )
}


void operatorOverload() :
{}
{
    <PLUS> | <MINUS> | <STAR> | <DIV> | <ASSIGN> | <EQ> | <LT> | <GT>
}

void parameterList() :
{}
{
    parameter() ( <COMMA> parameter() )*
}

void parameter() :
{}
{
    ( <CONST> | <VAR> | <READONLY> )?
    <IDENTIFIER> ( <COLON> type() )? ( <ASSIGN> expression() )?
}

void functionBody() :
{}
{
    blockStatement() | expressionBody()
}

void expressionBody() :
{}
{
    ARROW() expression()
}

void methodCall() :
{}
{
    ( <DOT> | <NULL_SAFE> ) <IDENTIFIER> <LPAREN> ( argumentList() )? <RPAREN>
}


void fieldAccess() :
{}
{
    ( <DOT> | <NULL_SAFE> ) <IDENTIFIER>
}

void arrayAccess() :
{}
{
    <LBRACKET> expression() <RBRACKET>
}

void functionCall() :
{}
{
    <LPAREN> ( argumentList() )? <RPAREN>
}


void argumentList() :
{}
{
    expression() ( <COMMA> expression() )*
}

// ============================================================
// CLASES Y ESTRUCTURAS
// ============================================================

void classDeclaration() :
{}
{
    ( <ABSTRACT> | <SEALED> | <FINAL> )?
    <CLASS> <IDENTIFIER>
    ( typeParameterList() )?
    ( EXTENDS() type() )?
    ( IMPLEMENTS() typeList() )?
    classBody()
}

void classBody() :
{}
{
    <LBRACE> ( classMember() )* <RBRACE>
}

void classMember() :
{}
{
    fieldDeclaration()
    | methodDeclaration()
    | constructorDeclaration()
    | destructorDeclaration()
    | propertyDeclaration()
    | <SEMICOLON>
}

void fieldDeclaration() :
{}
{
    ( accessModifier() )?
    ( <STATIC> | <VOLATILE> | <READONLY> | <WRITEONLY> )?
    variableDeclaration() <SEMICOLON>
}

void methodDeclaration() :
{}
{
    ( accessModifier() )?
    ( <OVERRIDE> | <VIRTUAL> | <ABSTRACT> | <STATIC> )?
    functionDeclaration()
}

void constructorDeclaration() :
{}
{
    ( accessModifier() )?
    <CONSTRUCTOR> <LPAREN> (parameterList())? <RPAREN>
    ( <THROWS> exceptionList() )?
    ( constructorInitializer() )?
    blockStatement()
}

void constructorInitializer() :
{}
{
    <COLON> ( <BASE> | <THIS> ) <LPAREN> (argumentList())? <RPAREN>
}

void destructorDeclaration() :
{}
{
    <DESTRUCTOR> <LPAREN> <RPAREN> blockStatement()
}

void propertyDeclaration() :
{}
{
    ( accessModifier() )?
    <PROPERTY> type() <IDENTIFIER>
    <LBRACE>
    ( getter() (setter())? | setter() (getter())? )
    <RBRACE>
}

void getter() :
{}
{
    <GETTER> blockStatement()
}

void setter() :
{}
{
    <SETTER> <LPAREN> parameter() <RPAREN> blockStatement()
}

void accessModifier() :
{}
{
    <PUBLIC> | <PRIVATE> | <PROTECTED> | <INTERNAL> | <PACKAGE_VIS>
}

// ============================================================
// INTERFACES
// ============================================================

void interfaceDeclaration() :
{}
{
    <INTERFACE> <IDENTIFIER>
    ( typeParameterList() )?
    ( EXTENDS() typeList() )?
    interfaceBody()
}

void interfaceBody() :
{}
{
    <LBRACE> ( interfaceMember() )* <RBRACE>
}

void interfaceMember() :
{}
{
    LOOKAHEAD( methodSignature() <SEMICOLON> ) 
    methodSignature() <SEMICOLON>
    | LOOKAHEAD( propertySignature() <SEMICOLON> )
    propertySignature() <SEMICOLON>
    | <SEMICOLON>
}

void methodSignature() :
{}
{
    ( <IDENTIFIER> | <OPERATOR> operatorOverload() )
    <LPAREN> (parameterList())? <RPAREN> ( <COLON> type() )?
}

void propertySignature() :
{}
{
    <IDENTIFIER> <COLON> type()
}

// ============================================================
// ESTRUCTURAS Y ENUMS
// ============================================================

void structDeclaration() :
{}
{
    <STRUCT> <IDENTIFIER> structBody()
}

void structBody() :
{}
{
    <LBRACE> ( structMember() )* <RBRACE>
}

void structMember() :
{}
{
    variableDeclaration() <SEMICOLON>
}

void enumDeclaration() :
{}
{
    <ENUM> <IDENTIFIER> ( <COLON> type() )? enumBody()
}

void enumBody() :
{}
{
    <LBRACE> enumMember() ( <COMMA> enumMember() )* <RBRACE>
}

void enumMember() :
{}
{
    <IDENTIFIER> ( <ASSIGN> expression() )?
}

// ============================================================
// TIPOS
// ============================================================

void type() :
{}
{
    baseType() ( typeSuffix() )*
}

void baseType() :
{}
{
    simpleType()
    | LOOKAHEAD(2) functionType()
    | LOOKAHEAD(2) tupleType()
    | LOOKAHEAD(2) genericType()
    | <LPAREN> type() <RPAREN>
}

void typeSuffix() :
{}
{
    arraySuffix()
    | pointerSuffix()
    | referenceSuffix()
    | nullableSuffix()
}

void arraySuffix() :
{}
{
    <LBRACKET> ( expression() )? <RBRACKET>
}

void pointerSuffix() :
{}
{
    <STAR> | <UNIQUE_PTR> | <SHARED_PTR> | <SMART_PTR>
}

void referenceSuffix() :
{}
{
    <AMP> | <MUT_REF>
}

void nullableSuffix() :
{}
{
    <TERNARY>
}

// Las otras definiciones se simplifican:
void arrayType() :
{}
{
    baseType() arraySuffix() ( typeSuffix() )*
}

void pointerType() :
{}
{
    baseType() pointerSuffix() ( typeSuffix() )*
}

void referenceType() :
{}
{
    baseType() referenceSuffix() ( typeSuffix() )*
}

void nullableType() :
{}
{
    baseType() nullableSuffix() ( typeSuffix() )*
}

void functionType() :
{}
{
    <LPAREN> ( parameterTypeList() )? <RPAREN> ARROW() type()
}

void tupleType() :
{}
{
    <LPAREN> type() ( <COMMA> type() )+ <RPAREN>
}

void genericType() :
{}
{
    <IDENTIFIER> typeArgumentList()
}

void simpleType() :
{}
{
    <INT8> | <INT16> | <INT32> | <INT64>
    | <UINT8> | <UINT16> | <UINT32> | <UINT64>
    | <FLOAT32> | <FLOAT64> | <DOUBLE> | <DECIMAL>
    | <CHAR> | <STRING> | <BOOLEAN> | <VOID>
    | <ANY> | <NEVER> | <UNKNOWN> | <NONE>
    | <IDENTIFIER>
}

void parameterTypeList() :
{}
{
    type() ( <COMMA> type() )*
}

void typeArgumentList() :
{}
{
    <LT> type() ( <COMMA> type() )* <GT>
}

void typeParameterList() :
{}
{
    <LT> <TYPE_PARAM> ( <COMMA> <TYPE_PARAM> )* <GT>
}

void typeList() :
{}
{
    type() ( <COMMA> type() )*
}

// ============================================================
// TEMPLATES Y GENÉRICOS
// ============================================================

void templateDeclaration() :
{}
{
    <TEMPLATE> typeParameterList()
    ( <WHERE> constraintList() )?
    declarationStatement()
}

void constraintList() :
{}
{
    constraint() ( <COMMA> constraint() )*
}

void constraint() :
{}
{
    <TYPE_PARAM> <COLON> type()
}

// ============================================================
// MANEJO DE EXCEPCIONES
// ============================================================

void exceptionHandlingStatement() :
{}
{
    tryCatchStatement()
    | throwStatement()
}

void tryCatchStatement() :
{}
{
    <TRY> blockStatement()
    ( <CATCH> <LPAREN> parameter() <RPAREN> blockStatement() )*
    ( <FINALLY> blockStatement() )?
}

void throwStatement() :
{}
{
    <THROW> expression() <SEMICOLON>
}

void exceptionList() :
{}
{
    type() ( <COMMA> type() )*
}

// ============================================================
// ASERCIONES
// ============================================================

void assertionStatement() :
{}
{
    ( <ASSERT> | <REQUIRE_JS> | <ENSURE> ) expression() <SEMICOLON>
}

// ============================================================
// SINCRONIZACIÓN
// ============================================================

void synchronizationStatement() :
{}
{
    <SYNC> <LPAREN> expression() <RPAREN> blockStatement()
    | <LOCK> <LPAREN> expression() <RPAREN> blockStatement()
    | <MUTEX> blockStatement()
}

// ============================================================
// GESTIÓN DE MEMORIA
// ============================================================

void memoryManagementStatement() :
{}
{
    <NEW> type() ( <LPAREN> (argumentList())? <RPAREN> )? <SEMICOLON>
    | <DELETE> expression() <SEMICOLON>
    | <FREE> <LPAREN> expression() <RPAREN> <SEMICOLON>
    | <MALLOC> <LPAREN> expression() <RPAREN> <SEMICOLON>
    | <CALLOC> <LPAREN> expression() <COMMA> expression() <RPAREN> <SEMICOLON>
    | <REALLOC> <LPAREN> expression() <COMMA> expression() <RPAREN> <SEMICOLON>
    | <ALLOCATE> <LPAREN> expression() <RPAREN> <SEMICOLON>
    | <GC> <LPAREN> <RPAREN> <SEMICOLON>
}

// ============================================================
// MÓDULOS E IMPORTACIONES
// ============================================================

void importStatement() :
{}
{
    <IMPORT> 
    ( <IDENTIFIER> ( <DOT> <IDENTIFIER> )* | <STRING_LIT> )
    ( <FROM> <STRING_LIT> )?
    <SEMICOLON>
}

void exportStatement() :
{}
{
    <EXPORT> 
    ( declarationStatement() | <LBRACE> exportList() <RBRACE> )
    ( <SEMICOLON> )?
}

void exportList() :
{}
{
    <IDENTIFIER> ( <COMMA> <IDENTIFIER> )*
}

void namespaceDeclaration() :
{}
{
    <NAMESPACE> <IDENTIFIER> blockStatement()
}

void usingStatement() :
{}
{
    <USING> 
    ( <IDENTIFIER> ( <ASSIGN> type() )? | <LPAREN> usingList() <RPAREN> )
    <SEMICOLON>
}

void usingList() :
{}
{
    usingDirective() ( <COMMA> usingDirective() )*
}

void usingDirective() :
{}
{
    <IDENTIFIER> ( <ASSIGN> type() )?
}

// ============================================================
// ANOTACIONES Y DECORADORES
// ============================================================

void annotationStatement() :
{}
{
    <AT> ( <IDENTIFIER> | ANNOTATION() )
    ( <LPAREN> (annotationArguments())? <RPAREN> )?
    ( declarationStatement() | classMember() )
}

void annotationArguments() :
{}
{
    annotationArgument() ( <COMMA> annotationArgument() )*
}

void annotationArgument() :
{}
{
    ( <IDENTIFIER> <ASSIGN> )? expression()
}

// ============================================================
// PREPROCESADOR
// ============================================================

void preprocessorStatement() :
{}
{
    <PREPROC>
    | <INCLUDE_DIR> ( <STRING_LIT> | includePath() ) (<SEMICOLON>)?
    | <DEFINE> <IDENTIFIER> ( expression() )? (<SEMICOLON>)?
    | <IFDEF> <IDENTIFIER> (<SEMICOLON>)?
    | <IFNDEF> <IDENTIFIER> (<SEMICOLON>)?
    | <ENDIF> (<SEMICOLON>)?
    | <PRAGMA> pragmaContent() (<SEMICOLON>)?
}

void includePath() :
{}
{
    <LT> ( <IDENTIFIER> | <DOT> | <DIV> )* <GT>
}

void pragmaContent() :
{}
{
    ( <IDENTIFIER> | <STRING_LIT> | <INT> )*
}

// ============================================================
// SQL
// ============================================================

void sqlStatement() :
{}
{
    selectStatement() <SEMICOLON>
    | insertStatement() <SEMICOLON>
    | updateStatement() <SEMICOLON>
    | deleteSqlStatement() <SEMICOLON>
}

void selectStatement() :
{}
{
    <SELECT> ( <DISTINCT> )? selectList()
    <FROM_SQL> tableSource()
    ( <WHERE_SQL> expression() )?
    ( <GROUP_BY_SQL> expression() ( <COMMA> expression() )* )?
    ( <HAVING> expression() )?
    ( <ORDER_BY_SQL> orderList() )?
    ( <LIMIT> expression() ( <OFFSET> expression() )? )?
}

void selectList() :
{}
{
    ( expression() ( <AS> <IDENTIFIER> )? ) ( <COMMA> expression() ( <AS> <IDENTIFIER> )? )*
}

void tableSource() :
{}
{
    <IDENTIFIER> ( <AS> <IDENTIFIER> )?
    ( joinClause() )*
}

void joinClause() :
{}
{
    ( <INNER_JOIN> | <LEFT_JOIN> | <RIGHT_JOIN> | <FULL_JOIN> | <CROSS_JOIN> )
    <IDENTIFIER> ( <AS> <IDENTIFIER> )?
    ( <ON_SQL> expression() )?
}

void orderList() :
{}
{
    expression() ( ASC() | DESC() )? ( <COMMA> expression() ( ASC() | DESC() )? )*
}

void insertStatement() :
{}
{
    <INSERT> <INTO> <IDENTIFIER>
    ( <LPAREN> columnList() <RPAREN> )?
    <VALUES> <LPAREN> valueList() <RPAREN>
}

void columnList() :
{}
{
    <IDENTIFIER> ( <COMMA> <IDENTIFIER> )*
}

void valueList() :
{}
{
    expression() ( <COMMA> expression() )*
}

void updateStatement() :
{}
{
    <UPDATE> <IDENTIFIER>
    <SET_SQL> setClause()
    ( <WHERE_SQL> expression() )?
}

void setClause() :
{}
{
    <IDENTIFIER> <ASSIGN> expression() ( <COMMA> <IDENTIFIER> <ASSIGN> expression() )*
}

void deleteSqlStatement() :
{}
{
    <DELETE_SQL> <FROM_SQL> <IDENTIFIER>
    ( <WHERE_SQL> expression() )?
}

// ============================================================
// HTTP
// ============================================================

void httpStatement() :
{}
{
    httpMethod() <LPAREN> (argumentList())? <RPAREN> <SEMICOLON>
}

void httpMethod() :
{}
{
    <HTTP_GET> | <POST> | <PUT> | <PATCH> | <DELETE_HTTP> | <HEAD> | <OPTIONS>
}